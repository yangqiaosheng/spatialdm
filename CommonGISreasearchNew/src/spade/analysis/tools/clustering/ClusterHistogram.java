package spade.analysis.tools.clustering;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.util.Vector;

import spade.lib.util.IntArray;

/**
 * Created by IntelliJ IDEA.
 * Creator: N.Andrienko
 * Date: 19-Apr-2007
 * Time: 16:41:08
 */
public class ClusterHistogram extends Canvas {
	/**
	 * The clustered objects in the order produced by OPTICS (or another algorithm)
	 */
	protected Vector<DClusterObject> objectsOrdered = null;

	protected int nObj = 0;
	protected float[] rval = null, cval = null;
	protected int[] ival = null;
	protected float min = Float.NaN, max = Float.NaN;
	protected float threshold = Float.NaN;
	protected int lastW = 0, lastH = 0;
	protected float vStep = 0;
	protected int pixPerObj = 1;
	protected int level = -1;
	protected Graphics g = null;
	/**
	 * Contains the cluster numbers (starting from 0) corresponding to the
	 * clustered objects. A value below 0 means that the corresponding object
	 * is treated as noise.
	 */
	protected int[] objClusters = null;
	/**
	 * The colors assigned to the clusters (this does not include the
	 * color for the noise).
	 */
	protected Color[] clColors = null;
	/**
	 * The color assigned to indicate the noise.
	 */
	protected Color noiseColor = Color.gray;
	/**
	 * Identifiers of selected objects
	 */
	protected IntArray selObjNs = null;

	/**
	 * @param objectsOrdered - clustered objects in the order generated by the clustering algorithm
	 */
	public ClusterHistogram(Vector<DClusterObject> objectsOrdered) {
		this.objectsOrdered = objectsOrdered;
		setBackground(Color.white);
		if (objectsOrdered == null)
			return;
		nObj = objectsOrdered.size();
		if (nObj < 1)
			return;
		rval = new float[nObj];
		cval = new float[nObj];
		for (int i = 0; i < nObj; i++) {
			DClusterObject clObj = objectsOrdered.elementAt(i);
			rval[i] = (float) clObj.reachabilityDistance;
			cval[i] = (float) clObj.coreDistance;
			if (!Float.isNaN(rval[i])) {
				if (Float.isNaN(min) || min > rval[i]) {
					min = rval[i];
				}
				if (Float.isNaN(max) || max < rval[i]) {
					max = rval[i];
				}
			} else if (!Float.isNaN(cval[i])) {
				if (Float.isNaN(min) || min > cval[i]) {
					min = cval[i];
				}
				if (Float.isNaN(max) || max < cval[i]) {
					max = cval[i];
				}
			}
		}
	}

	public float getMin() {
		return min;
	}

	public float getMax() {
		return max;
	}

	public float[] getReachabilityDistances() {
		return rval;
	}

	public float[] getCoreDistances() {
		return cval;
	}

	public void setThreshold(float threshold) {
		if (this.threshold == threshold)
			return;
		this.threshold = threshold;
		if (objClusters != null) {
			objClusters = null;
			redraw();
			return;
		}
		if (isShowing() && vStep > 0) {
			int l = -1;
			if (!Float.isNaN(threshold) && threshold < max) {
				l = Math.round(threshold / vStep);
			}
			if (l != level) {
				if (g == null) {
					g = getGraphics();
				}
				g.setColor(Color.red);
				g.setXORMode(Color.lightGray);
				if (level > 0 && level < lastH) {
					g.drawLine(0, lastH - level, lastW, lastH - level);
				}
				g.setPaintMode();
				draw(g);
			}
		}
	}

	/**
	 * Sets the cluster numbers (starting from 0) corresponding to the
	 * clustered objects. A value below 0 means that the corresponding object
	 * is treated as noise.
	 */
	public void setObjectClusters(int objClusters[]) {
		this.objClusters = objClusters;
	}

	/**
	 * Sets the colors assigned to the clusters (this does not include the
	 * color for the noise).
	 */
	public void setClusterColors(Color clColors[]) {
		this.clColors = clColors;
	}

	/**
	 * Sets the color to indicate the noise.
	 */
	public void setNoiseColor(Color noiseColor) {
		this.noiseColor = noiseColor;
	}

	public float getThreshold() {
		return threshold;
	}

	@Override
	public Dimension getPreferredSize() {
		if (nObj < 1)
			return new Dimension(50, 50);
		int w = nObj;
		while (w < 300) {
			w += nObj;
		}
		return new Dimension(w, 200);
	}

	public void setSelectedObjectNs(IntArray selNs) {
		selObjNs = selNs;
	}

	@Override
	public void paint(Graphics g) {
		draw(g);
	}

	public void draw(Graphics g) {
		Dimension size = getSize();
		if (size.width != lastW || size.height != lastH) {
			lastW = size.width;
			lastH = size.height;
			pixPerObj = lastW / nObj;
			if (pixPerObj < 1) {
				pixPerObj = 1;
			}
			vStep = max / lastH;
			if (ival == null) {
				ival = new int[nObj];
			}
			for (int i = 0; i < nObj; i++) {
				float val = rval[i];
				if (Float.isNaN(val) && i < nObj - 1 && !Float.isNaN(cval[i]) && !Float.isNaN(rval[i + 1])) {
					val = cval[i];
				}
				if (Float.isNaN(val)) {
					ival[i] = -1;
				} else {
					ival[i] = Math.round(val / vStep);
				}
			}
		}
		int x = 0;
		level = -1;
		if (!Float.isNaN(threshold) && threshold < max) {
			level = Math.round(threshold / vStep);
		}
		for (int i = 0; i < nObj; i++) {
			Color color = null;
			if (selObjNs != null && selObjNs.indexOf(i) >= 0) {
				color = Color.black;
			} else if (objClusters != null && i < objClusters.length && clColors != null)
				if (objClusters[i] >= 0) {
					color = clColors[objClusters[i]];
				} else {
					color = noiseColor;
				}
			if (color == null) {
				color = (ival[i] < 0) ? Color.gray : (ival[i] <= level) ? Color.green : Color.lightGray;
			}
			g.setColor(color);
			int h = (ival[i] >= 0) ? ival[i] : lastH;
			g.fillRect(x, lastH - h, pixPerObj + 1, h + 1);
			x += pixPerObj;
		}
		if (level > 0 && level < lastH) {
			g.setColor(Color.red);
			g.setXORMode(Color.lightGray);
			g.drawLine(0, lastH - level, lastW, lastH - level);
			g.setPaintMode();
		}
	}

	public void redraw() {
		if (g == null) {
			g = getGraphics();
		}
		if (g != null) {
			draw(g);
			if (level > 0 && level < lastH) {
				g.setColor(Color.red);
				g.setXORMode(Color.lightGray);
				g.drawLine(0, lastH - level, lastW, lastH - level);
				g.setPaintMode();
			}
		}
	}

	public int getObjNForPos(int x, int y) {
		if (vStep <= 0)
			return -1;
		if (x < 0 || x > lastW || y < 0 || y > lastH)
			return -1;
		int n = x / pixPerObj;
		if (n >= nObj)
			return -1;
		int h = (ival[n] >= 0) ? ival[n] : lastH;
		if (y < lastH - h)
			return -1;
		return n;
	}
}
