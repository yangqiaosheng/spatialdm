package spade.analysis.tools.clustering;

import it.unipi.di.sax.kmedoids.KMedoids;
import it.unipi.di.sax.optics.DistanceMeter;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Frame;
import java.awt.TextArea;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Vector;

import spade.analysis.system.DataLoader;
import spade.analysis.system.DisplayProducer;
import spade.analysis.system.ESDACore;
import spade.lib.basicwin.Dialogs;
import spade.lib.basicwin.OKFrame;
import spade.vis.database.Attribute;
import spade.vis.database.AttributeTypes;
import spade.vis.database.DataRecord;
import spade.vis.database.DataTable;
import spade.vis.dmap.DGeoLayer;
import spade.vis.dmap.DGeoObject;
import spade.vis.dmap.DrawingParameters;
import spade.vis.map.MapViewer;

/**
 * Created by IntelliJ IDEA.
 * User: Natascha
 * Date: Jan 8, 2009
 * Time: 2:42:37 PM
 * Builds a classifier based on results of clustering.
 * The classifier may be applied to assign objects from a database or
 * from another map layer to earlier defined clusters.
 */
public class ClassifierBuilder implements ClusterRefiner, WindowListener, ActionListener {
	protected ESDACore core = null;

	public ClassifierBuilder(ESDACore core) {
		this.core = core;
	}

	protected void showMessage(String msg, boolean error) {
		if (core != null && core.getUI() != null) {
			core.getUI().showMessage(msg, error);
		} else if (error) {
			System.out.println("!--> " + msg);
		}
	}

	/**
	 * Shows a report about the progress of the cluster refinement
	 */
	protected Frame reportFrame = null;
	/**
	 * Contains a report about the progress of the cluster refinement
	 */
	protected TextArea reportArea = null;
	/**
	 * The UI to examine, test, and modify the classifier
	 */
	protected ClassifierBuilderUI cbUI = null;
	/**
	 * Contains the UI to examine, test, and modify the classifier
	 */
	protected OKFrame uiFrame = null;
	/**
	 * A new map layer, which contains the specimens of the clusters.
	 * The layer is generated by the ClassifierBuilder.
	 */
	protected DGeoLayer spLayer = null;
	/**
	 * A copy of the layer containing the specimens of the clusters.
	 * This copy appears in another map window.
	 * The ClassifierBuilder does not make any changes in the main
	 * window but uses an additional map window.
	 */
	protected DGeoLayer spLayerCopy = null;
	/**
	 * A table attached to the layer with the cluster specimens.
	 * The table is generated by the ClassifierBuilder.
	 */
	protected DataTable spTable = null;
	/**
	 * The "working" map viewer, in which the specimens of the clusters are shown
	 */
	protected MapViewer workMapView = null;
	/**
	 * Contains information about clusters, which can be used for classification
	 * of objects from a database.
	 */
	protected ClustersInfo clustersInfo = null;

	/**
	 * Refines currently selected OPTICS-generated clusters using the Sweep Plane approach
	 * @param lClusterer - contains the results of the clustering by OPTICS
	 * @param table - the table with the clusters
	 * @param origClusterColN - the index of the table column containing the original
	 *   assignment of the objects to the clusters
	 * @param refinedClusterColN - the index of the table column containing the
	 *   assignment of the objects to the refined clusters, if this column has been
	 *   previously created
	 * @return the index of the table column containing the assignment of the objects to the
	 *   refined clusters. If this column did not exist before, the ClusterRefiner creates it.
	 */
	@Override
	public int refineClusters(LayerClusterer lClusterer, DataTable table, int origClusterColN, int refinedClusterColN) {
		return refineClusters(lClusterer, table, origClusterColN, refinedClusterColN, true);
	}

	/**
	 * Refines currently selected OPTICS-generated clusters
	 * @param lClusterer - contains the results of the clustering by OPTICS
	 * @param table - the table with the clusters
	 * @param origClusterColN - the index of the table column containing the original
	 *   assignment of the objects to the clusters
	 * @param refinedClusterColN - the index of the table column containing the
	 *   assignment of the objects to the refined clusters, if this column has been
	 *   previously created
	 * @param useSweepPlane - whether to use the Sweep Plane approach
	 *   (otherwise K-Medoids with pre-selected seeds will be used)
	 * @return the index of the table column containing the assignment of the objects to the
	 *   refined clusters. If this column did not exist before, the ClusterRefiner creates it.
	 */
	public int refineClusters(LayerClusterer lClusterer, DataTable table, int origClusterColN, int refinedClusterColN, boolean useSweepPlane) {
		showMessage(null, false);
		if (lClusterer == null || table == null || origClusterColN < 0)
			return -1;

		lClusterer.setMayUseThresholdInComputingDistances(false);
		lClusterer.eraseInfinitiesInDistanceMatrix();

		DGeoLayer layer = lClusterer.getLayer();
		if (layer == null)
			return -1;
		Vector<DClusterObject> objectsOrdered = lClusterer.getObjectsOrdered();
		if (objectsOrdered == null)
			return -1;
		int nObj = objectsOrdered.size();
		if (nObj < 1)
			return -1;
		//erase the results of the previous refinement
		for (int i = 0; i < nObj; i++) {
			DClusterObject clobj = objectsOrdered.elementAt(i);
			clobj.isSpecimen = false;
			clobj.subIdx = -1;
			clobj.specimenId = null;
		}
		if (refinedClusterColN >= 0) {
			for (int i = 0; i < table.getDataItemCount(); i++) {
				table.getDataRecord(i).setAttrValue(null, refinedClusterColN);
			}
		}

		boolean newColumn = refinedClusterColN < 0;

		if (reportFrame != null) {
			reportFrame.removeWindowListener(this);
		} else {
			reportArea = new TextArea(40, 60);
			reportFrame = core.getDisplayProducer().makeWindow(reportArea, "Cluster refinement");
			/*
			reportFrame=new Frame("Cluster refinement");
			reportFrame.setLayout(new BorderLayout());
			reportFrame.add(reportArea,BorderLayout.CENTER);
			reportFrame.pack();
			Dimension d=reportFrame.getSize(),
			          ss=Toolkit.getDefaultToolkit().getScreenSize();
			if (d.width>ss.width*3/4) d.width=ss.width*3/4;
			if (d.height>ss.height*3/4) d.height=ss.height*3/4;
			int x=ss.width-d.width,y=0;
			reportFrame.setBounds(x,y,d.width,d.height);
			reportFrame.setVisible(true);
			*/
		}

		if (clustersInfo == null) {
			clustersInfo = new ClustersInfo();
			clustersInfo.table = table;
			clustersInfo.clustersColN = origClusterColN;
			clustersInfo.objContainer = layer;
			LayerClusterer lcl = lClusterer.getCopy();
			//lcl.distanceThreshold=Double.NaN;
			lcl.distMatrix = lClusterer.distMatrix;
			clustersInfo.distanceMeter = lcl;
		} else {
			clustersInfo.clear();
		}
		reportArea.setText(null);

		long t0 = System.currentTimeMillis();
		double maxRadius = lClusterer.distanceThreshold;
		if (useSweepPlane) {
			maxRadius = Dialogs.askForDoubleValue(core.getUI().getMainFrame(), "Maximum radius of a subcluster?", maxRadius, lClusterer.distanceThreshold / 2, lClusterer.distanceThreshold * 5,
					"To select appropriate cluster prototypes, the density-based clusters " + "will be divided into \"round\" subclusters.", "Maximum subcluster radius", false);
			refinedClusterColN = refineBySweepPlane(maxRadius, lClusterer, table, origClusterColN, refinedClusterColN, newColumn);
		} else {
			refinedClusterColN = refineBySelectingSeeds(lClusterer, table, origClusterColN, refinedClusterColN, newColumn);
		}
		long t = System.currentTimeMillis() - t0;
		reportArea.append("\r\nElapsed time : " + t + " msec, " + (t / 1000) + " sec\r\n");

		reportFrame.addWindowListener(this);

		putClusterSpecimensOnMap();
		DClusterObject clusteredObjects[] = new DClusterObject[objectsOrdered.size()];
		for (int i = 0; i < objectsOrdered.size(); i++) {
			clusteredObjects[i] = (DClusterObject) objectsOrdered.elementAt(i).clone();
		}
		if (cbUI == null) {
			cbUI = new ClassifierBuilderUI(lClusterer.layer, clusteredObjects, clustersInfo, spLayerCopy, spTable, 0, maxRadius, workMapView, core);
			uiFrame = new OKFrame(this, "Build a classifier", true);
			uiFrame.addContent(cbUI);
			uiFrame.pack();
			Dimension sd = Toolkit.getDefaultToolkit().getScreenSize(), wd = uiFrame.getSize();
			uiFrame.setLocation(sd.width - wd.width, 0);
			uiFrame.setVisible(true);
		} else {
			cbUI.resetPrimaryClusters(clusteredObjects);
		}

		return refinedClusterColN;
	}

	protected int refineBySelectingSeeds(LayerClusterer lClusterer, DataTable table, int origClusterColN, int refinedClusterColN, boolean newColumn) {
		if (lClusterer == null || table == null)
			return -1;
		DGeoLayer layer = lClusterer.getLayer();
		if (layer == null)
			return -1;
		Vector<DClusterObject> objectsOrdered = lClusterer.getObjectsOrdered();
		if (objectsOrdered == null)
			return -1;
		int nObj = objectsOrdered.size();
		if (nObj < 1)
			return -1;

		ArrayList<DClusterObject> data = new ArrayList<DClusterObject>(nObj);
		ArrayList<DClusterObject> seeds = new ArrayList<DClusterObject>(Math.min(nObj / 10, 100));
		double thrMax = lClusterer.getDistanceThreshold() / 2;
		int currClusterIdx = -1;
		for (int i = 0; i < objectsOrdered.size(); i++) {
			DClusterObject clObj = objectsOrdered.elementAt(i);
			if (layer.isObjectActive(clObj.idx) && clObj.clusterIdx >= 0) {
				if (clObj.clusterIdx != currClusterIdx) {
					//1) refine the previous cluster, if any
					if (data.size() > 0) {
						if (newColumn) {
							refinedClusterColN = makeTableColumnsForRefinedClusters(table, origClusterColN);
							if (refinedClusterColN < 0)
								return -1;
						}
						SingleClusterInfo result = refineClusterByKMedoids(data, seeds, lClusterer, table, refinedClusterColN, reportArea);
						if (result != null) {
							clustersInfo.addSingleClusterInfo(result);
							visualizeRefinedClusters(table, refinedClusterColN, newColumn, layer);
							newColumn = false;
						}
						data.clear();
						seeds.clear();
					}
					//2) start processing current cluster
					//choose an appropriate distance threshold for this cluster
					currClusterIdx = clObj.clusterIdx;
					double max = Double.NaN;
					for (int j = i; j < objectsOrdered.size() && objectsOrdered.elementAt(j).clusterIdx == currClusterIdx; j++) {
						DClusterObject co = objectsOrdered.elementAt(j);
						if (!Double.isNaN(co.reachabilityDistance)) {
							if (Double.isNaN(max) || max < co.reachabilityDistance) {
								max = co.reachabilityDistance;
							}
						}
					}
					thrMax = 0.95 * max;
				}
				data.add(clObj);
				if (Double.isNaN(clObj.coreDistance) || Double.isNaN(clObj.reachabilityDistance) || clObj.reachabilityDistance > thrMax) {
					seeds.add(clObj);
				}
			}
		}
		if (data.size() > 0) {
			if (newColumn) {
				refinedClusterColN = makeTableColumnsForRefinedClusters(table, origClusterColN);
				if (refinedClusterColN < 0)
					return -1;
			}
			SingleClusterInfo result = refineClusterByKMedoids(data, seeds, lClusterer, table, refinedClusterColN, reportArea);
			if (result != null) {
				clustersInfo.addSingleClusterInfo(result);
				visualizeRefinedClusters(table, refinedClusterColN, newColumn, layer);
			}
		}
		return refinedClusterColN;
	}

	protected int refineBySweepPlane(double maxRadius, LayerClusterer lClusterer, DataTable table, int origClusterColN, int refinedClusterColN, boolean newColumn) {
		if (lClusterer == null || table == null)
			return -1;
		DGeoLayer layer = lClusterer.getLayer();
		if (layer == null)
			return -1;
		Vector<DClusterObject> objectsOrdered = lClusterer.getObjectsOrdered();
		if (objectsOrdered == null)
			return -1;
		int nObj = objectsOrdered.size();
		if (nObj < 1)
			return -1;

		int currClusterIdx = -1, fromIdx = -1, toIdx = -1;
		for (int i = 0; i < objectsOrdered.size(); i++) {
			DClusterObject clObj = objectsOrdered.elementAt(i);
			if (layer.isObjectActive(clObj.idx) && clObj.clusterIdx >= 0) {
				if (clObj.clusterIdx != currClusterIdx) {
					//1) refine the previous cluster, if any
					if (fromIdx >= 0 && toIdx >= fromIdx) {
						if (newColumn) {
							refinedClusterColN = makeTableColumnsForRefinedClusters(table, origClusterColN);
							if (refinedClusterColN < 0)
								return -1;
						}
						SingleClusterInfo result = this.refineClusterBySweepPlane(objectsOrdered, fromIdx, toIdx, maxRadius, lClusterer, table, refinedClusterColN, reportArea);
						if (result != null) {
							clustersInfo.addSingleClusterInfo(result);
							visualizeRefinedClusters(table, refinedClusterColN, newColumn, layer);
							newColumn = false;
						}
						fromIdx = toIdx = -1;
					}
					//2) remember the index of the first object of the current cluster
					//choose an appropriate distance threshold for this cluster
					currClusterIdx = clObj.clusterIdx;
					fromIdx = i;
				}
				toIdx = i;
			}
		}
		if (fromIdx >= 0 && toIdx >= fromIdx) {
			if (newColumn) {
				refinedClusterColN = makeTableColumnsForRefinedClusters(table, origClusterColN);
				if (refinedClusterColN < 0)
					return -1;
			}
			SingleClusterInfo result = this.refineClusterBySweepPlane(objectsOrdered, fromIdx, toIdx, maxRadius, lClusterer, table, refinedClusterColN, reportArea);
			if (result != null) {
				clustersInfo.addSingleClusterInfo(result);
				visualizeRefinedClusters(table, refinedClusterColN, newColumn, layer);
			}
		}
		return refinedClusterColN;
	}

	/**
	 * Constructs or updates a map layer with the cluster specimens
	 */
	protected void putClusterSpecimensOnMap() {
		if (clustersInfo == null || clustersInfo.getClustersCount() < 1)
			return;
		if (clustersInfo.distanceMeter == null || !(clustersInfo.distanceMeter instanceof LayerClusterer))
			return;
		LayerClusterer lClusterer = (LayerClusterer) clustersInfo.distanceMeter;
		if (lClusterer.layer == null)
			return;
		core.getHighlighterForSet(lClusterer.layer.getEntitySetIdentifier()).clearSelection(this);

		DataTable prevSPTable = spTable;
		spTable = new DataTable();
		if (prevSPTable != null) {
			spTable.setName(prevSPTable.getName());
		} else {
			String suffix = "clusters";
			if (clustersInfo.table != null && clustersInfo.clustersColN >= 0) {
				suffix = clustersInfo.table.getAttributeName(clustersInfo.clustersColN);
			}
			spTable.setName("Prototypes of the " + suffix);
		}
		spTable.setEntitySetIdentifier(lClusterer.layer.getEntitySetIdentifier());
		spTable.addAttribute("Cluster N", "_cluster_N_", AttributeTypes.character);
		if (clustersInfo.table != null && clustersInfo.clustersColN >= 0) {
			Attribute clAttr = clustersInfo.table.getAttribute(clustersInfo.clustersColN);
			spTable.getAttribute(0).setValueListAndColors(clAttr.getValueList(), clAttr.getValueColors());
		}
		spTable.addAttribute("Prototype N", "_specimen_N_", AttributeTypes.integer);
		spTable.addAttribute("Distance threshold", "_distance_thr_", AttributeTypes.real);
		spTable.addAttribute("N of neighbours", "_N_neighbours_", AttributeTypes.integer);
		spTable.addAttribute("Mean distance to neighbours", "_min_dist_neighb_", AttributeTypes.real);

		Vector<DGeoObject> spObjects = new Vector(50, 50);
		for (int clIdx = 0; clIdx < clustersInfo.clusterInfos.size(); clIdx++) {
			SingleClusterInfo clIn = clustersInfo.clusterInfos.elementAt(clIdx);
			if (clIn.specimens != null && clIn.specimens.size() > 0) {
				for (int spIdx = 0; spIdx < clIn.specimens.size(); spIdx++) {
					ClusterSpecimenInfo spec = clIn.specimens.elementAt(spIdx);
					if (spec.specimen != null) {
						DGeoObject gobj = lClusterer.getDGeoObject(spec.specimen);
						if (gobj != null) {
							DGeoObject copy = (DGeoObject) gobj.makeCopy();
							copy.setIsHighlighted(false);
							copy.setIsSelected(false);
							spObjects.addElement(copy);
							DataRecord rec = new DataRecord(copy.getIdentifier(), copy.getLabel());
							spTable.addDataRecord(rec);
							rec.setAttrValue(clIn.clusterLabel, 0);
							rec.setNumericAttrValue(spIdx + 1, String.valueOf(spIdx + 1), 1);
							rec.setNumericAttrValue(spec.distanceThr, String.valueOf(spec.distanceThr), 2);
							rec.setNumericAttrValue(spec.nSimilarOrig, String.valueOf(spec.nSimilarOrig), 3);
							rec.setNumericAttrValue(spec.meanDistOrig, String.valueOf(spec.meanDistOrig), 4);
						}
					}
				}
			}
		}
		if (spObjects.size() < 1)
			return;
		DataLoader dLoader = core.getDataLoader();
		if (prevSPTable != null) {
			dLoader.removeTable(prevSPTable.getContainerIdentifier());
		}
		for (int i = 0; i < spObjects.size(); i++) {
			spObjects.elementAt(i).setThematicData(spTable.getDataRecord(i));
		}
		if (spLayer == null) {
			spLayer = new DGeoLayer();
			spLayer.setType(lClusterer.layer.getType());
			spLayer.setName(spTable.getName());
			spLayer.setGeoObjects(spObjects, true);
			spLayer.setGeographic(lClusterer.layer.isGeographic());
			spLayer.setHasMovingObjects(lClusterer.layer.getHasMovingObjects());
			spLayer.setEntitySetIdentifier(lClusterer.layer.getEntitySetIdentifier());
			DrawingParameters dp = spLayer.getDrawingParameters();
			if (dp == null) {
				dp = new DrawingParameters();
				spLayer.setDrawingParameters(dp);
			}
			dp.lineColor = Color.getHSBColor((float) Math.random(), 1 - 0.2f * (float) Math.random(), 1 - 0.2f * (float) Math.random());
			dp.lineWidth = 2;
			dp.transparency = 0;
			dLoader.addMapLayer(spLayer, -1);
			dLoader.processTimeReferencedObjectSet(spLayer);

			spLayer.setLayerDrawn(false);

			workMapView = core.getUI().getMapViewer("_blank_");
			//find the copy of the geographical layer in the new map view
			int lidx = workMapView.getLayerManager().getIndexOfLayer(spLayer.getContainerIdentifier());
			if (lidx >= 0) {
				spLayerCopy = (DGeoLayer) workMapView.getLayerManager().getGeoLayer(lidx);
			}
			lidx = workMapView.getLayerManager().getIndexOfLayer(lClusterer.layer.getContainerIdentifier());
			if (lidx >= 0) {
				((DGeoLayer) workMapView.getLayerManager().getGeoLayer(lidx)).setLayerDrawn(false);
			}
		} else {
			DisplayProducer dpr = core.getDisplayProducer();
			dpr.eraseDataFromMap(spLayerCopy, workMapView);
			//spLayer.removeAllObjects();
			spLayer.setGeoObjects(spObjects, true);
			spLayer.notifyPropertyChange("ObjectSet", null, null);
			//spLayerCopy.removeAllObjects();
			spLayerCopy.setGeoObjects(spObjects, true);
			spLayerCopy.notifyPropertyChange("ObjectSet", null, null);
		}
		int tblN = dLoader.addTable(spTable);
		dLoader.processTimeReferencedObjectSet(spTable);
		spLayer.setDataTable(spTable);
		dLoader.setLink(spLayer, tblN);
		spLayer.setLinkedToTable(true);
		spLayer.setThematicFilter(spTable.getObjectFilter());
		spLayerCopy.setDataTable(spTable);
		dLoader.setLink(spLayerCopy, tblN);
		spLayerCopy.setLinkedToTable(true);
		spLayerCopy.setThematicFilter(spTable.getObjectFilter());

		if (spLayerCopy != null && workMapView != null) {
			DisplayProducer dpr = core.getDisplayProducer();
			Vector clAttr = new Vector(1, 1);
			clAttr.addElement(spTable.getAttributeId(0));
			dpr.displayOnMap("qualitative_colour", spTable, clAttr, spLayerCopy, workMapView);
		}

	}

	protected int makeTableColumnsForRefinedClusters(DataTable table, int origClusterColN) {
		if (table == null)
			return -1;
		String attrName = (origClusterColN >= 0) ? table.getAttributeName(origClusterColN) + "; refined" : "Clusters refined";
		String colName = Dialogs.askForStringValue(core.getUI().getMainFrame(), "Column name?", attrName, "A column with cluster names will be created in the table " + table.getName(), "New column", false);
		if (colName == null)
			return -1;
		Attribute attr = new Attribute("_clusters_" + (table.getAttrCount() + 1), AttributeTypes.character);
		attr.setName(colName);
		table.addAttribute(attr);
		int refinedClusterColN = table.getAttrCount() - 1;
		attrName = "Centroids of " + attrName;
		colName = Dialogs.askForStringValue(core.getUI().getMainFrame(), "Column name?", attrName, "A column with cluster centroids will be created in the table " + table.getName(), "New column", false);
		attr = new Attribute("_centroids_" + (table.getAttrCount() + 1), AttributeTypes.character);
		attr.setName(colName);
		table.addAttribute(attr);
		return refinedClusterColN;
	}

	protected void visualizeRefinedClusters(DataTable table, int refinedClusterColN, boolean newColumn, DGeoLayer layer) {
		Vector clAttr = new Vector(2, 1);
		clAttr.addElement(table.getAttributeId(refinedClusterColN));
		if (newColumn) {
			MapViewer mw = core.getUI().getMapViewer("_blank_");
			//find the copy of the geographical layer in the new map view
			int lidx = mw.getLayerManager().getIndexOfLayer(layer.getContainerIdentifier());
			if (lidx >= 0) {
				layer = (DGeoLayer) mw.getLayerManager().getGeoLayer(lidx);
			} else {
				mw = core.getUI().getMapViewer("main");
			}
			DisplayProducer dpr = core.getDisplayProducer();
			dpr.displayOnMap("qualitative_colour", table, clAttr, layer, mw);
		} else {
			clAttr.addElement(table.getAttributeId(refinedClusterColN + 1));
			table.notifyPropertyChange("values", null, clAttr);
		}
	}

	protected SingleClusterInfo refineClusterBySweepPlane(Vector<DClusterObject> objectsOrdered, int fromIdx, int toIdx, double maxRadius, LayerClusterer lClusterer, DataTable table, int refinedClusterColN, TextArea reportArea) {
		if (objectsOrdered == null || fromIdx < 0 || objectsOrdered.size() < fromIdx + 1)
			return null;

		double distanceThreshold = lClusterer.distanceThreshold;
		lClusterer.distanceThreshold = Double.NaN;
		RoundClustersProducer<DClusterObject> rClProd = new RoundClustersProducer<DClusterObject>();
		HashMap<DClusterObject, ArrayList<DClusterObject>> result = rClProd.getRoundClusters(objectsOrdered, fromIdx, toIdx, lClusterer, maxRadius);
		int clusterN = objectsOrdered.elementAt(fromIdx).clusterIdx + 1;
		if (result == null || result.size() < 1) {
			reportArea.append("Cluster " + clusterN + ": failed to divide into subclusters!\r\n");
			return null;
		}

		reportArea.append("Cluster " + clusterN + " has been divided into " + result.size() + " subclusters.\r\n");
		SingleClusterInfo clInfo = makeSingleClusterInfo(result, clusterN, lClusterer, maxRadius, table, refinedClusterColN);
		lClusterer.distanceThreshold = distanceThreshold;

		if (clInfo == null || clInfo.getSpecimensCount() < 1)
			return null;

		Vector objIds = new Vector(result.size(), 5);
		for (int i = 0; i < clInfo.getSpecimensCount(); i++) {
			ClusterSpecimenInfo spec = clInfo.getClusterSpecimenInfo(i);
			objIds.addElement(spec.specimen.id);
/*
      reportArea.append("Specimen "+spec.specimen.id+": subcluster size = "+
        spec.nSimilarOrig+"; radius = "+spec.origDistanceThr+
        "; mean distance to the specimen = "+spec.meanDistOrig+"\r\n");
*/
		}
		reportArea.append("\r\n");
		core.getHighlighterForSet(table.getEntitySetIdentifier()).replaceSelectedObjects(this, objIds);
		return clInfo;
	}

	protected SingleClusterInfo refineClusterByKMedoids(ArrayList<DClusterObject> data, ArrayList<DClusterObject> seeds, LayerClusterer lClusterer, DataTable table, int refinedClusterColN, TextArea reportArea) {
		if (data == null || data.size() < 1) {
			showMessage("No active objects found!", true);
			return null;
		}
		int clusterN = data.get(0).clusterIdx + 1;
		boolean divide = false;
		if (data.size() < 4) {
			reportArea.append("Cluster " + clusterN + ": only " + data.size() + " objects; not divided.\r\n");
		} else if (seeds == null || seeds.size() < 1) {
			reportArea.append("Cluster " + clusterN + "(" + data.size() + " objects) : no suitable seeds; not divided.\r\n");
		} else if (seeds.size() < 2) {
			reportArea.append("Cluster " + clusterN + "(" + data.size() + " objects) : only one seed found; not divided.\r\n");
		} else {
			divide = true;
		}
		boolean reduced = false;
		if (divide) {
/*
      Vector objIds=new Vector(seeds.size());
      for (int i=0; i<seeds.size(); i++)
        objIds.addElement(seeds.get(i).id);
      core.getHighlighterForSet(table.getEntitySetIdentifier()).replaceSelectedObjects(this,objIds);
      Dialogs.showMessage(core.getUI().getMainFrame(),"Cluster border objects are selected","Cluster border objects");
*/
			//remove centres located close to others
			double minDistBetweenSeeds = lClusterer.distanceThreshold * 2;
			double minDist = Double.NaN;
			double minD[] = new double[seeds.size()], sumD[] = new double[seeds.size()];
			do {
				minDist = Double.NaN;
				int idx = -1;
				for (int i = 0; i < seeds.size(); i++) {
					minD[i] = Double.NaN;
					sumD[i] = 0;
					for (int j = 0; j < seeds.size(); j++)
						if (j != i) {
							double d = lClusterer.distance(seeds.get(i), seeds.get(j));
							if (Double.isNaN(minD[i]) || d < minD[i]) {
								minD[i] = d;
							}
							sumD[i] += d;
							if (Double.isNaN(minDist) || d < minDist) {
								minDist = d;
								idx = i;
							}
						}
				}
				if (idx >= 0 && minDist < minDistBetweenSeeds) {
					for (int i = 0; i < seeds.size(); i++)
						if (i != idx && minD[i] <= minDist && sumD[i] < sumD[idx]) {
							idx = i;
						}
					seeds.remove(idx);
					reduced = true;
				}
			} while (seeds.size() > 1 && !Double.isNaN(minDist) && minDist < minDistBetweenSeeds);
			if (seeds.size() < 2) {
				reportArea.append("Cluster " + clusterN + "(" + data.size() + " objects) : too small distance between candidate seeds (" + minDist + "); not divided.\r\n");
				divide = false;
			} else {
				reportArea.append("Cluster " + clusterN + "(" + data.size() + " objects) : distance between candidate seeds =" + minDist + "; will be divided.\r\n");
			}
		}
		Vector objIds = null;
/*
    if (seeds!=null && seeds.size()>0) {
      objIds=new Vector(seeds.size());
      for (int i=0; i<seeds.size(); i++)
        objIds.addElement(seeds.get(i).id);
      core.getHighlighterForSet(table.getEntitySetIdentifier()).replaceSelectedObjects(this,objIds);
    }
    else
      core.getHighlighterForSet(table.getEntitySetIdentifier()).clearSelection(this);
    if (reduced)
      Dialogs.showMessage(core.getUI().getMainFrame(),
        "Some of the cluster border objects have been skipped","Cluster border objects");
*/

		double distanceThreshold = lClusterer.distanceThreshold;
		lClusterer.distanceThreshold = Double.NaN;
		KMedoids<DClusterObject> km = new KMedoids<DClusterObject>(lClusterer);
		HashMap<DClusterObject, ArrayList<DClusterObject>> result = null;

		if (divide) {
			result = km.doClustering(data, seeds);

			if (result == null || result.size() < 2) {
				reportArea.append("Cluster " + clusterN + ": failed to divide by means of KMedoids; preserved.\r\n");
				divide = false;
			} else {
				reportArea.append("Cluster " + clusterN + " has been divided into " + result.size() + " subclusters.\r\n");
			}
		}
		if (!divide) {
			DClusterObject centre = km.getCentroid(data);
			if (centre == null) {
				reportArea.append("Cluster " + clusterN + ": failed to find a centroid.\r\n");
				lClusterer.distanceThreshold = distanceThreshold;
				return null;
			}
			result = new HashMap<DClusterObject, ArrayList<DClusterObject>>(10);
			result.put(centre, data);
		}
		SingleClusterInfo clInfo = makeSingleClusterInfo(result, clusterN, lClusterer, distanceThreshold, table, refinedClusterColN);
		lClusterer.distanceThreshold = distanceThreshold;

		if (clInfo == null || clInfo.getSpecimensCount() < 1)
			return null;

		if (objIds == null) {
			objIds = new Vector(result.size(), 5);
		} else {
			objIds.removeAllElements();
		}
		for (int i = 0; i < clInfo.getSpecimensCount(); i++) {
			objIds.addElement(clInfo.getClusterSpecimenInfo(i).specimen.id);
		}
		core.getHighlighterForSet(table.getEntitySetIdentifier()).replaceSelectedObjects(this, objIds);
		return clInfo;
	}

	public double getClusterRadius(ArrayList<DClusterObject> cluster, DClusterObject centroid, DistanceMeter dm) {
		if (cluster == null || centroid == null || cluster.size() < 1)
			return Double.NaN;
		double maxd = 0;
		for (DClusterObject member : cluster) {
			// member: cluster member
			double d = dm.distance(centroid, member);
			if (d > maxd) {
				maxd = d;
			}
		}
		return maxd;
	}

	protected SingleClusterInfo makeSingleClusterInfo(HashMap<DClusterObject, ArrayList<DClusterObject>> subClusters, int clusterN, DistanceMeter dm, double distanceThreshold, DataTable table, int refinedClusterColN) {
		if (subClusters == null || subClusters.size() < 1)
			return null;
		SingleClusterInfo clInfo = new SingleClusterInfo();
		clInfo.clusterN = clusterN;
		clInfo.clusterLabel = String.valueOf(clusterN);
		clInfo.origSize = 0;

		int clN = 0;

		for (DClusterObject centre : subClusters.keySet()) {
			if (centre == null) {
				continue;
			}
			int idx = table.indexOf(centre.id);
			if (idx < 0) {
				continue;
			}
			centre.isSpecimen = true;
			centre.subIdx = clN;
			centre.specimenId = centre.id;
			++clN;
			ArrayList<DClusterObject> cluster = subClusters.get(centre);
			clInfo.origSize += cluster.size();

			ClusterSpecimenInfo clSpec = new ClusterSpecimenInfo();
			clSpec.specimen = centre;
			clSpec.nSimilarOrig = cluster.size();
			clSpec.distanceThr = getClusterRadius(cluster, centre, dm);
			if (clSpec.distanceThr < distanceThreshold / 5) {
				clSpec.distanceThr = distanceThreshold / 5;
			}
			clSpec.origDistanceThr = clSpec.distanceThr;
			clInfo.addSpecimen(clSpec);

			String clName = String.valueOf(centre.clusterIdx + 1) + "." + clN;
			reportArea.append(clName + " : size = " + cluster.size() + "; radius = " + clSpec.distanceThr + "; centroid ID = " + centre.id + "\r\n");
			DataRecord rec = table.getDataRecord(idx);
			rec.setAttrValue(clName, refinedClusterColN);
			rec.setAttrValue("yes", refinedClusterColN + 1);

			double sumDist = 0;

			for (DClusterObject member : cluster)
				if (!member.equals(centre)) {
					idx = table.indexOf(member.id);
					if (idx < 0) {
						continue;
					}
					member.isSpecimen = false;
					member.subIdx = centre.subIdx;
					member.specimenId = centre.specimenId;
					rec = table.getDataRecord(idx);
					rec.setAttrValue(clName, refinedClusterColN);
					rec.setAttrValue("no", refinedClusterColN + 1);
					sumDist += dm.distance(centre, member);
				}
			clSpec.meanDistOrig = sumDist / clSpec.nSimilarOrig;
		}
		return clInfo;
	}

	public void actionPerformed(ActionEvent e) {
		if (e.getSource().equals(uiFrame) && e.getActionCommand().equals("closed")) {
			//store the classifier
			if (!uiFrame.wasCancelled() && cbUI != null) {
				ClustersInfo clInfoMod = cbUI.getClustersInfo();
				((LayerClusterer) clInfoMod.distanceMeter).distMatrix = null;
				ObjectsToClustersAssigner clAssigner = new ObjectsToClustersAssigner(clInfoMod);
				String name = Dialogs.askForStringValue(core.getUI().getMainFrame(), "Name of the classifier?", clAssigner.getName(), null, "Name of the classifier?", false);
				clAssigner.setName(name);
				core.registerProcessor(clAssigner);
				showMessage("The classifier has been added to the tools for analysis", false);
				if (spLayer != null && spLayerCopy != null && spLayer.getObjectCount() < spLayerCopy.getObjectCount()) {
					for (int i = spLayer.getObjectCount(); i < spLayerCopy.getObjectCount(); i++) {
						spLayer.addGeoObject((DGeoObject) spLayerCopy.getObject(i).makeCopy());
					}
				}
				DGeoLayer origLayer = cbUI.getOrigLayer();
				DataTable table = (DataTable) origLayer.getThematicData();
				if (table != null) {
					String prompts[] = { "Class labels:", "Is a prototype? (yes or no):" };
					String aNames[] = { "Class by " + name, "Prototype in " + name + "?" };
					aNames = Dialogs.editStringValues(core.getUI().getMainFrame(), prompts, aNames, "To store the resulting classes, in the table, 2 attributes will be added. " + "Specify the names of the new attributes:", "Store classes in table",
							true);
					if (aNames != null) {
						int i0 = table.getAttrCount();
						table.addAttribute(aNames[0], "_classes_" + i0, AttributeTypes.character);
						table.addAttribute(aNames[1], "_is_specimen_" + i0, AttributeTypes.character);
						DClusterObject clusteredObjects[] = cbUI.getClusteredObjects();
						for (DClusterObject clusteredObject : clusteredObjects) {
							DataRecord rec = table.getDataRecord(table.indexOf(clusteredObject.id));
							if (rec != null) {
								if (clusteredObject.clusterIdx >= 0) {
									rec.setAttrValue(String.valueOf(clusteredObject.clusterIdx + 1), i0);
								} else {
									rec.setAttrValue("noise", i0);
								}
								rec.setAttrValue((clusteredObject.isSpecimen) ? "yes" : "no", i0 + 1);
							}
						}
						Vector v = new Vector(2, 1);
						v.add(table.getAttributeId(i0));
						v.add(table.getAttributeId(i0 + 1));
						table.notifyPropertyChange("new_attributes", null, v);
						v.removeElementAt(1);
						Attribute attr = table.getAttribute(i0), attr0 = spTable.getAttribute("_cluster_N_");
						if (attr0 != null) {
							attr.setValueListAndColors(attr0.getValueList(), attr0.getValueColors());
						}
						core.getDisplayProducer().displayOnMap("qualitative_colour", table, v, origLayer, cbUI.getMapViewer());
					}
				}
			} else if (cbUI != null) {
				cbUI.restoreState(0, false);
			}
			uiFrame.dispose();
			uiFrame = null;
			cbUI.destroy();
			cbUI = null;
			clustersInfo = null;
			spLayer = null;
			spLayerCopy = null;
			spTable = null;
			workMapView = null;
		}
	}

	public void windowClosing(WindowEvent e) {
		if (e.getSource().equals(reportFrame)) {
			reportFrame.dispose();
			reportFrame = null;
		}
	}

	public void windowClosed(WindowEvent e) {
		if (e.getSource().equals(reportFrame)) {
			reportFrame = null;
		}
	}

	public void windowOpened(WindowEvent e) {
	}

	public void windowIconified(WindowEvent e) {
	}

	public void windowDeiconified(WindowEvent e) {
	}

	public void windowActivated(WindowEvent e) {
	}

	public void windowDeactivated(WindowEvent e) {
	}
}
